# Графики и Сети

## Введение

> id: intro-0
> section: introduction
> color: "#A7208A"
> level: Intermediate
> next: probability
> translated: auto

Каждый день мы окружены бесчисленными связями и сетями: автомобильные и железнодорожные пути, телефонные линии, интернет, электронные схемы и даже молекулярные связи. Есть даже _социальные сети_ между друзьями и семьями. Можете ли вы вспомнить другие примеры?

::: column(width=220 parent="padded-thin")

    x-img(src="images/network1.jpg" width=220 height=220 lightbox)

{.caption} Автомобильные и железнодорожные сети

::: column(width=220)

    x-img(src="images/network6.jpg" width=220 height=220 lightbox)

{.caption} Компьютерные чипы

::: column(width=220)

    x-img(src="images/network3.jpg" width=220 height=220 lightbox)

{.caption} Каналы поставок

::: column(width=220)

    x-img(src="images/network2.jpg" width=220 height=220 lightbox)

{.caption} Дружеские

::: column(width=220)

    x-img(src="images/network7.jpg" width=220 height=220 lightbox)

{.caption} Нейронные Связи

::: column(width=220)

    x-img(src="images/network4.jpg" width=220 height=220 lightbox)

{.caption} Интернет

:::

---
> id: intro

::: column.grow

В математике все эти примеры могут быть представлены в виде [__графиков__](gloss:graph) (не путать с _графиком_ функции). Граф состоит из определенных _точек,_ называемых [[вершинами | круги | переходы]] , некоторые из которых соединены [[ребрами | границы | пары]]

__Теория графов__ - это изучение графов и их свойств. Это одна из самых захватывающих и визуальных областей математики, которая имеет бесчисленное множество важных приложений.

::: column(width=180)

    svg#graph0.graph.novertices.noedges(width=180 height=180)

:::

---
> id: intro-1

Мы можем нарисовать макет простых графиков, используя круги и линии. Положение вершин и длина ребер не имеет значения - нас интересует только то, _как они связаны_ друг с другом. Края могут даже пересекаться, и не должны быть прямыми.

::: column(width=200)

    svg.graph(height=120 width=200 style="margin: 0 auto .8em")

{.caption} На некоторых графиках ребра идут только в одну сторону. Это так называемые [__ориентированные графы__](gloss:directed-graph) .

::: column(width=200)

    svg.graph(height=120 width=200 style="margin: 0 auto .8em")

{.caption} Некоторые графы состоят из нескольких групп вершин, которые не связаны друг с другом ребрами. Эти графики __отключены__ .

::: column(width=200)

    svg.graph(height=120 width=200 style="margin: 0 auto .8em")

{.caption} Другие графы могут содержать несколько ребер между одинаковыми парами вершин или вершинами, которые связаны между собой (петлями).

:::

---
> id: intro-2

Мы можем создать новые графы из существующего графа, удалив некоторые вершины и ребра. Результат называется [__подграфом__](gloss:subgraph) . Здесь вы можете увидеть еще несколько примеров графиков с цветными ребрами и вершинами, указывающими на возможный подграф:

::: column(width=212 parent="padded-thin")

    svg.graph(height=100 width=100 style='float: left; margin-right: 12px')
    svg.graph(height=100 width=100 style='float: left')

::: column(width=212)

    svg.graph(height=100 width=100 style='float: left; margin-right: 12px')
    svg.graph(height=100 width=100 style='float: left')

::: column(width=212)

    svg.graph(height=100 width=100 style='float: left; margin-right: 12px')
    svg.graph(height=100 width=100 style='float: left')

:::

---
> id: intro-3

Мы говорим, что [__порядок__](gloss:graph-order) графа - это число вершин, которые он имеет. [__Степень__](gloss:graph-degree) вершины - это число ребер, которые встречаются в этой вершине.

::: column(width=130)

    svg.graph(height=120 width=120 style='margin: 0 auto .8em')

{.text-center} Заказ: [[5]]

::: column(width=130)

    svg.graph(height=120 width=120 style='margin: 0 auto .8em')

{.text-center} Заказ: [[8]]

::: column(width=130)

    svg.graph(height=120 width=120 style='margin: 0 auto .8em')

{.text-center} Степень: [[3]]

::: column(width=130)

    svg.graph(height=120 width=120 style='margin: 0 auto .8em')

{.text-center} Степень: [[6]]

:::

---
> id: intro-4

Графы, состоящие из одного цикла вершин, называются [__циклами__](gloss:graph-cycle) . Все циклы имеют [[одинаковое количество ребер и вершин | больше ребер, чем вершин | меньше ребер, чем вершин]] .

    .row
      svg.graph(style='width: 120px; height: 120px;')
      svg.graph(style='width: 120px; height: 120px;')
      svg.graph(style='width: 120px; height: 120px;')

{.reveal(when="blank-0")} Оснащенные этими новыми определениями, давайте рассмотрим некоторые из интересных свойств и приложений графов.

---
> id: bridges-0
> title: The Bridges of Königsberg
> section: bridges
> translated: auto

## Мосты Кенигсберга

::: column.grow

Одним из первых математиков, который подумал о графах и сетях, был [Леонард Эйлер](bio:euler) . Эйлер был заинтригован старой проблемой города Кенигсберга у Балтийского моря.

Река Прегель делит Кенигсберг на четыре отдельные части, которые соединены семью мостами. Можно ли прогуляться по городу, пересекая все мосты ровно один раз, но не более одного раза? (Вы можете начать и закончить где угодно, не обязательно в том же месте.)

Попробуйте найти правильный маршрут, нарисовав на этих картах:

::: column(width=250)

    img.shifted(src="images/konigsberg1.jpg" width=250 height=350)

:::

---
> id: bridges
> goals: bridge-0 bridge-1 bridge-2 bridge-3
> title: The Bridges of Königsberg

    x-tabbox.full-width
      .tab
        h3 Map 1#[span.check.incorrect(when="bridge-0")]
        x-solved
        include svg/bridges-1.svg
        button.btn Clear
        button.btn.right Skip
      .tab
        h3 Map 2#[span.check(when="bridge-1")]
        x-solved
        include svg/bridges-2.svg
        button.btn Clear
        button.btn.right Skip
      .tab
        h3 Map 3#[span.check(when="bridge-2")]
        x-solved
        include svg/bridges-3.svg
        button.btn Clear
        button.btn.right Skip
      .tab
        h3 Map 4 #[span.check.incorrect(when="bridge-3")]
        x-solved
        include svg/bridges-4.svg
        button.btn Clear
        button.btn.right Skip

---
> id: bridges-1

В случае Кенигсберга, кажется, невозможно найти правильный маршрут, но некоторые другие города работают. Эйлеру удалось найти простое правило, которое можно применить к любому городу, не прибегая к множеству возможностей - используя теорию графов.

::: column.grow

Во-первых, нам нужно преобразовать карты города в графы с ребрами и вершинами. Каждый остров или регион суши представлен [[вершиной | край | область]] и каждый мост, соединяющий две области, представлены соответствующим [[ребром | вершина | улица]]

{.reveal(when="blank-0 blank-1")} Теперь проблема «путешествовать по городу, пересекая каждый мост ровно один раз», превратилась в задачу «нарисовать график одним непрерывным штрихом, в то же время отслеживая каждый край ровно один раз».

::: column(width=200)

    include svg/konigsberg.svg

:::

---
> id: bridges-2

На бумаге придумайте несколько разных графиков, а затем попытайтесь определить, какие из них можно нарисовать одним непрерывным штрихом.

---
> id: bridges-3
> goals: size prime eo

Как и в случае с картами городов, мы находим, что некоторые графики возможны, а другие нет. Чтобы помочь нам понять почему, давайте пометим каждую вершину ее [степенью](gloss:graph-degree) . Затем мы можем по-разному раскрасить вершины и попытаться выявить закономерность:

    figure
      x-select.var.tabs(:bind="colour")
        div(value="val") Value
        div(value="size") Size
        div(value="prime") Prime Numbers
        div(value="eo") Even and Odd
      .box
        p.no-voice(style="margin: 0"): strong These graphs are possible:
        include svg/vertex-orders-1.svg
        p.no-voice(style="margin: 1em 0 0"): strong These graphs are not possible:
        include svg/vertex-orders-2.svg

---
> id: bridges-4

Сравнивая эти числа для графов, которые возможны, и тех, которые невозможны, кажется, что граф можно нарисовать, если он [[имеет не более двух «нечетных» вершин. | имеет только «четные» вершины | не имеет вершин с порядком больше 4 | имеет нечетное количество вершин | не имеет вершин порядка 3]] . Это условие можно объяснить, если мы посмотрим только на одну вершину в графе:

    x-slideshow
      .stage(slot="stage"): include svg/konigsberg-proof.svg
      .legend(slot="legend") Here you can see a single, magnified vertex in a graph.
      .legend(slot="legend") If we draw the graph, we will eventually have an edge leading towards this vertex, and then another one leading away. This makes two edges meeting at the vertex.
      .legend(slot="legend") Maybe the vertex is a crossing rather than a corner. In that case there will be another edge leading towards the vertex, and another edge leading away. Now we have four edges.
      .legend(slot="legend") And in some graphs, there may even be a third pair of edges leading towards and away from the vertex. Now there are six edges.
      .legend(slot="legend") Notice that, either way, there always is an even number of edges meeting at the vertex.
      .legend(slot="legend") The only two exceptions are the vertices where the path starts, and where it ends – these two may have an odd number of edges. If the start and end point are the same, all vertices in the graph are even.

---
> id: bridges-5

::: column.grow(parent="right")

Если вы вернетесь к карте Кенигсберга, вы обнаружите, что существует более двух островов с нечетным числом мостов. Поэтому маршрут, который пересекает каждый мост ровно один раз, действительно невозможен - и это то, что открыл Леонард Эйлер.

Открытие Эйлера может показаться не особенно полезным в реальной жизни, но графики лежат в основе многих других географических проблем, таких как поиск направлений между двумя точками. Мы узнаем больше об этих приложениях позже.

::: column(width=240)

    x-img(lightbox width=240 height=260 src="images/prague.jpg")

:::

---
> id: handshakes-1
> section: handshakes
> translated: auto

## Рукопожатия и знакомства

::: column.grow

Вы были приглашены на замечательную вечеринку по случаю дня рождения со своими друзьями. Включая себя и хозяина, есть ${hnd}{hnd|5|3,15,1} люди присутствуют.

Вечером, когда гости собираются уходить, все пожимают друг другу руки. Сколько всего рукопожатий?

Мы можем изобразить рукопожатия, используя график: каждый человек - [[вершина | край]] , и каждое рукопожатие [[это край | вершина]] .

{.reveal(when='blank-0 blank-1')} Теперь легко подсчитать количество ребер в графе. Мы находим, что там с ${hnd} люди есть ${hnd*(hnd-1)/2} рукопожатия.

::: column.s-hide(width=240)

    img.shifted(src="images/party.jpg" width=240 height152)
    svg.graph(style='width: 240px; height: 240px;')

:::

---
> id: handshakes-2

Вместо того, чтобы считать все ребра на больших графиках, мы могли бы также попытаться найти простую формулу, которая сообщает нам результат для _любого_ количества гостей.

Каждый из ${n}{n|5|2,8,1} люди на вечеринке пожимают друг другу руки ${n-1} другие. Что делает ${n} × ${n-1} знак равно ${n×(n-1)} Всего рукопожатий. Для _русских_ людей количество рукопожатий будет [[`n×(n–1)`|`n×(n+1)`|`n^2`]] ,

    p.var(:html="handshakeTable(n)")
    x-gesture(target="#handshakes-2 x-var" slide="100,0")

---
> id: handshakes-2a

К сожалению, этот ответ не совсем правильный. Обратите внимание, как [первые две записи в верхнем ряду](->.handshakes_tr:first-child_td:first-child,_.handshakes_tr:first-child_td:nth-child(2)) на самом деле то же самое, просто перевернул.

На самом деле, мы посчитали каждое рукопожатие [[дважды | один раз | три раза]] , _{span.reveal(when="blank-0")} один раз для каждого из двух вовлеченных людей. Это означает, что правильное количество рукопожатий для ${n}{n|5|2,25,1} гости `(var("n") × var("n-1"))/2 = var("n*(n-1)/2")` ,_

---
> id: handshakes-3

Графы рукопожатия являются особыми, потому что каждая вершина связана с любой другой вершиной. Графы с этим свойством называются __полными графами__ . Полный граф с 4 вершинами часто сокращается до `K_4` , полный граф с 5 вершинами известен как `K_5` , и так далее.

Мы только что показали, что полный граф с `n` вершины, `K_n` имеет `(n × (n-1))/2` кромки.

    .row
      svg.graph(style="width: 90px; height: 90px")
      svg.graph(style="width: 90px; height: 90px")
      svg.graph(style="width: 90px; height: 90px")
      svg.graph(style="width: 90px; height: 90px")

---
> id: handshakes-4

    figure: img(src="images/flags.jpg" width=855 height=100)

В другой день вы приглашены на мероприятие по быстрому знакомству для ${m}{m|5|2,8,1} мальчики и ${f}{f|4|2,8,1} девушки. Здесь много маленьких столиков, и каждый мальчик проводит по 5 минут с каждой из девочек. Сколько отдельных «дат» в общей сложности?

::: column.grow

В этом случае соответствующий граф состоит из двух отдельных наборов вершин. Каждая вершина связана со всеми вершинами в [[противоположном | его собственный]] набор, но ни одна из вершин в [[его собственном | противоположный]] набор. Графики с таким расположением называются __двудольными__ .

::: column(width=300)

    svg.graph(style="width: 300px; height: 140px;")

:::

{.reveal(when="blank-0 blank-1")} Двудольный граф с двумя наборами размера _x_ и _y_ часто записывается как `K_"x,y"` , Оно имеет [[`x×y`|`x+y`|`2x–y`]] края, _{span.reveal(when="blank-2")} Это означает, что в приведенном выше примере есть ${m} × ${f} знак равно ${m×f} даты._

---
> id: utilities
> goals: try-three-times
> section: planar-graphs
> translated: auto

## Планарные Графики

::: column.grow

Вот еще одна загадка, связанная с теорией графов.

В маленькой деревне есть три дома и три коммунальных предприятия, которые производят воду, электричество и газ. Мы должны подключить каждый из курсов к каждому из коммунальных предприятий, но из-за расположения деревни различные трубы и кабели не могут пересекаться.

::: column(width=300)

    x-img(width=300 height=200 src="images/power-plant.jpg")

:::

Попробуйте подключить каждый из домов к каждой из нижеуказанных коммунальных компаний, не пересекая линии

    .box.no-padding
      include svg/utilities.svg
      button.btn Clear

---
> id: utilities-1

Как и ранее Кенигсбергские мосты, вы быстро обнаружите, что эта проблема также невозможна. Кажется, что некоторые графики могут быть нарисованы без перекрывающихся ребер - они называются __плоскими графами__ - но другие не могут.

::: column(width=200)

    svg.graph(width=200 height=200 style="margin-bottom: .4em")

{.text-center}`K_3` плоская

::: column(width=200)

    svg.graph#planar-2(width=200 height=200 style="margin-bottom: .4em")

{.text-center}`K_4` [[плоский | не плоский]]

::: column(width=200)

    svg.graph#planar-3(width=200 height=200 style="margin-bottom: .4em;")

{.text-center}`K_5` [[не плоский | плоская]]

:::

---
> id: utilities-2

[Полный график](gloss:complete-graph) `K_5` самый маленький график, который не является плоским. Любой другой график, который содержит `K_5` как подграф в некотором роде тоже не плоский. Это включает `K_6` , `K_7` и все большие полные графики.

Граф в головоломке трех утилит является [двудольным графом](gloss:bipartite-graph) `K_"3,3"` , Оказывается, что любой непланарный граф должен содержать `K_5` или `K_"3,3"` (или [подразделение](gloss:subdivision) этих двух графиков) как подграф. Это называется _теорема Куратовского_ .

---
> id: planarity
> goals: planarity

::: .box.f-blue

#### Planarity

    x-solved
    svg#planarity(viewBox="0 0 720 360")

Это планарный график, но ${n}{n|7|5,20,1} вершины были зашифрованы. Переставьте вершины так, чтобы ни одно из ребер не перекрывалось.

    p.btn-row: button.btn New Random Graph

:::

---
> id: euler

### Формула Эйлера

Все плоские графики делят плоскость, на которой они нарисованы, на несколько областей, называемых __гранями__ .

::: column(width=200)

    include svg/euler-2.svg

{.text-center} [[6]] вершин
[[5]] лиц
[[10]] ребер
_{span.euler-sum} 11 Вершин + Лица_

::: column(width=200)

    include svg/euler-1.svg

{.text-center} [[8]] вершин
[[7]] лиц
[[14]] ребер
_{span.euler-sum} 15 Вершин + Лица_

::: column(width=200)

    include svg/euler-3.svg

{.text-center} [[12]] вершин
[[13]] лиц
[[24]] края
_{span.euler-sum} 25 Вершин + Лица_

:::

---
> id: euler-1

Сравнивая эти числа, вы заметите, что количество ребер всегда на [[один меньше | больше | столько же,]] сколько количество граней плюс количество вершин. Другими словами, _{.b.blue} F_ + _{.b.green} V_ = _{.b.red} E_ + 1. Этот результат называется __уравнением Эйлера__ и назван в честь того же [математика,](bio:euler) который решил задачу Кенигсбергских мостов.

К сожалению, существует бесконечно много графиков, и мы не можем проверить каждый из них, чтобы увидеть, работает ли уравнение Эйлера. Вместо этого мы можем попытаться найти простое [доказательство,](gloss:proof) которое работает для любого графа ...

---
> id: euler-2

    x-slideshow
      .stage(slot="stage")
        svg(viewBox="0 0 640 200")
          line.link(style="stroke-width: 3px; display: none" x1=270 y1=30  x2=150 y2=100)
          line.link(style="stroke-width: 3px; display: none" x1=150 y1=100 x2=270 y2=170)
          line.link(style="stroke-width: 3px; display: none" x1=270 y1=170 x2=390 y2=100)
          line.link(style="stroke-width: 3px" x1="390" y1="100" x2="270" y2="30")
          circle.node(cx=270 cy=30  r=7)
          circle.node(cx=150 cy=100 r=7 style="display: none")
          circle.node(cx=270 cy=170 r=7 style="display: none")
          circle.node(cx=390 cy=100 r=7 style="display: none")

        .euler-table
          table.grid.table-small
            tr
              td: strong.blue.i F
              td: strong.green.i V
              td: strong.red.i E
            tr
              td.xf 0
              td.xv 1
              td.xe 0
          p.no-voice #[strong.blue.xf 0] + #[strong.green.xv 1] &nbsp;=&nbsp; #[strong.red.xe 0] + 1

      .legend(slot="legend") The simplest graph consists of a single vertex. We can easily check that Euler’s equation works.
      .legend(slot="legend") Let us add a new vertex to our graph. We also have to add an edge, and Euler’s equation still works.
      .legend(slot="legend") If we want to add a third vertex to the graph we have two possibilities. We could create a small triangle: this adds one vertex, one face and two edges, so Euler’s equation still works.
      .legend(slot="legend") Instead we could simply extend the line by one: this adds one vertex and one edge, and Euler’s equation works.
      .legend(slot="legend") Let’s keep going: if we now create a quadrilateral we add one vertex, two edges and one face. Euler’s equation still works.

---
> id: euler-3

Любой (конечный) граф можно построить, начиная с одной вершины и добавляя больше вершин одну за другой. Мы показали, что, каким бы способом мы ни добавляли новые вершины, уравнение Эйлера справедливо. Поэтому это верно для всех графиков.

Процесс, который мы использовали, называется __математической индукцией__ . Это очень полезный метод для доказательства результатов в бесконечном количестве случаев, просто начиная с самого простого случая и показывая, что результат сохраняется на каждом этапе при построении более сложных случаев.

    .svg-block: include svg/dominoes.svg

---
> id: euler-4

Многие плоские графики очень похожи на сети [многогранников](gloss:polyhedron) , трехмерных фигур с [многоугольными](gloss:polygon) гранями. Если мы считаем, что многогранники сделаны из эластичных полос, мы можем представить, как растягиваем их, пока они не станут плоскими, плоскими графиками:

::: column(width=300)

    img.img-sequence(src="images/cube/cube0.png" width=300 height=300)
    x-slider(steps=31)

::: column(width=300)

    img.img-sequence(src="images/dodecahedron/dodeca0.png" width=300 height=300)
    x-slider(steps=31)

:::

---
> id: euler-5

Это означает, что мы можем использовать формулу Эйлера не только для плоских графов, но и для всех многогранников - с одним небольшим отличием. При преобразовании многогранников в графы одна из граней исчезает: верхняя грань многогранников становится «наружной»; графиков.

Другими словами, если вы посчитаете количество __{.red} края__ , __{.blue} лица__ и __{.green} вершины__ _любого_ многогранника, вы найдете, что _{.b.blue} F_ + _{.b.green} V_ = _{.b.red} E_ + [[2]] .

::: column(width=200)

    x-video(width=200 height=200 src="images/icosahedron.mp4" hover loop)

{.caption} __Икосаэдр__
__{.blue} 20__ лиц
__{.green} 12__ вершин
__{.red} 30__ ребер

::: column(width=200)

    x-video(width=200 height=200 src="images/rhombi.mp4" hover loop)

{.caption} __ромбоикосододекаэдр__
__{.blue} 62__ лица
__{.green} 60__ вершин
__{.red} 120__ ребер

::: column(width=200)

    x-video(width=200 height=200 src="images/football.mp4" hover loop)

{.caption} __Усеченный икосаэдр__
__{.blue} 32__ лица (12 черных, 20 белых)
__{.green} 60__ вершин
__{.red} 90__ ребер

:::

---
> id: maps
> section: map-colouring
> translated: auto

## Раскраска карты

::: column.grow

Мы уже использовали теорию графов с некоторыми картами. По мере уменьшения масштаба отдельные дороги и мосты исчезают, и вместо этого мы видим очертания целых стран.

При раскрашивании карты или любого другого рисунка, состоящего из отдельных регионов, смежные страны не могут иметь одинаковый цвет. Мы также можем использовать как можно меньше разных цветов.

Некоторым простым «картам», таким как шахматная доска, нужны только два цвета (черный и белый), но большинству сложных карт нужно больше.

::: column(width=240 style="margin-top: -10px")

    x-img.shifted(src="images/globe.jpg" width=240 height=320)

:::

---
> id: maps-1
> goals: map-0 map-1 map-2 map-3
> title: Colouring Maps

При раскрашивании карты штатов США, очевидно, достаточно 50 цветов, но нужно гораздо меньше. Попробуйте раскрасить карты ниже как можно меньшим количеством цветов:

    .four-colour-icons
      for i in [1, 2, 3, 4, 5, 6, 7]
        .four-colour-icon(tabindex=0)

    x-tabbox.four-colours.full-width
      .tab
        h3 United States #[span.check(when="map-0")]
        x-solved
        .colour-count(style="margin-bottom: -32px") #[span 0] colours used
        include svg/colours-1.svg
        button.btn.clear Clear
        // Note that states or countries which only share a corner are allowed to have the same colour.
        // Alaska and Hawaii are isolated from all of the other states and can have any colour.
      .tab
        h3 South America #[span.check(when="map-1")]
        x-solved
        .colour-count #[span 0] colours used
        include svg/colours-2.svg
        button.btn.clear Clear
      .tab
        h3 Germany #[span.check(when="map-2")]
        x-solved
        .colour-count #[span 0] colours used
        include svg/colours-3.svg
        button.btn.clear Clear
      .tab
        h3 England #[span.check(when="map-3")]
        x-solved
        .colour-count #[span 0] colours used
        include svg/colours-4.svg
        button.btn.clear Clear

---
> id: maps-2
> title: The Four Colour Theorem

::: column.grow

Все эти карты могут быть раскрашены только четырьмя разными цветами, но нетрудно представить, что другим, очень сложным картам может понадобиться гораздо больше цветов. На самом деле, некоторым картам нужно __по крайней мере__ четыре цвета, если они содержат четыре страны, все они связаны друг с другом.

::: column(width=200)

    img(src="images/four-colours.png" width=200 height=120)

:::

Как и раньше, мы можем преобразовать карту со странами и границами в планарный график: каждая страна становится [[вершиной | край | лицо]] и страны, [[имеющие общую границу | иметь тот же цвет,]] соединенный ребром:

    .svg-block: include svg/colour-graph.svg

{.reveal(when="blank-0 blank-1")} Теперь мы хотим раскрасить вершины графа, и две вершины должны иметь разный цвет, если они соединены ребром.

---
> id: maps-3

::: column(width=240 parent="right")

    x-img(lightbox width=240 height=320 src="images/england-counties.jpg")

::: column.grow

В 1852 году студент-ботаник [Фрэнсис Гатри](bio:guthrie) должен был раскрасить карту графств Англии. Он заметил, что четырех цветов, по-видимому, достаточно для любой карты, которую он пробовал, но он не смог найти доказательства, подходящего для _всех_ карт. Это оказалось чрезвычайно трудной проблемой и стало известно как __теорема__ о __четырех цветах__ .

В течение следующих 100 лет многие математики публиковали «доказательства» теоремы о четырех цветах только для ошибок, которые будут обнаружены позже. Некоторые из этих недействительных доказательств были настолько убедительными, что потребовалось более 10 лет, чтобы обнаружить ошибки.

Долгое время математики не могли ни доказать, что четырех цветов достаточно, либо найти карту, для которой требовалось более четырех цветов.

:::

---
> id: maps-4

Небольшой прогресс был достигнут по проблеме четырех цветов до 1976 года, когда [Вольфганг Хакен](bio:haken) и [Кеннет Аппель](bio:appel) использовали компьютер, чтобы наконец решить ее. Они сократили бесконечное количество возможных карт до 1936 особых случаев, каждая из которых проверялась компьютером, что занимало в общей сложности более 1000 часов.

    x-parallax.full-width(background="images/ibm-360.jpg")

---
> id: maps-5

Теорема четыре цвета является первой известной математической теоремы быть доказана с помощью компьютера, то, что стало гораздо более распространенным и менее спорным, так как. Более быстрые компьютеры и более эффективный алгоритм означают, что сегодня вы можете доказать теорему о четырех цветах на ноутбуке всего за несколько часов.

    figure
      x-img(src="images/suffice.jpg" width=320 height=80 credit="http://www.math.illinois.edu/History/postmarks.pdf")
      p.caption Postmark for the Department of Mathematics at the University of<br/>Illinois Urbana-Champaign, where Haken and Appel worked.

---
> id: maps-6

::: column.grow

Теорема о четырех цветах работает только для карт на плоской плоскости или сфере, где все страны состоят из одной области.

Однако математики также смотрели на карты _империй_ , где страны могут состоять из нескольких разрозненных компонентов, и карты на планетах различной формы, таких как тор (форма пончика). В этих случаях вам может понадобиться более четырех цветов, и доказательства становятся еще сложнее.

::: column(width=300)

    x-video(width=300 height=220 src="images/torus.mp4" hover loop)
    p.caption This map on a torus requires seven colours.

:::

---
> id: salesman
> section: travelling-salesman
> translated: auto

## Проблема коммивояжера

::: column.grow(parent="right")

Давайте еще раз подумаем о сетях и картах. Представьте, что служба доставки должна посетить ${tsn}{tsn|8|2,50,1} разные города для раздачи посылок. Мы можем думать об этих городах как о вершинах графа. Если все города связаны дорогами, это [[полный график | цикл | двудольный граф]] , так что есть <mfrac><mrow>${tsn} × ( ${tsn} - 1)</mrow><mn>2</mn></mfrac> знак равно ${tsn*(tsn-1)/2} края в общей сложности.

Служба доставки должна посетить все города, в любом порядке. В задаче о кенигсбергских мостах мы хотели найти пути, которые проходят по _каждому краю_ ровно по одному. Теперь мы хотим найти пути, которые посещают _каждую вершину_ ровно один раз. Эти пути называются __гамильтоновыми циклами__ .

::: column(width=260)

    x-img(src="images/truck.jpg" width=260 height=280)

:::

---
> id: salesman-1

Существует множество различных возможностей для гамильтоновых циклов в полных графах. Фактически, мы можем выбрать любую вершину в качестве начальной, а затем выбрать любой из оставшихся городов в любом порядке:

    .row
      .grow: p.todo Diagram coming soon…
      .grow: p.todo Diagram Coming Soon…

---
> id: salesman-2

В графе с ${tsn1}{tsn1|4|2,10,1} города, каждый гамильтонов цикл должен также содержать ${tsn1} города. Сейчас,

    ul.var(:html="tsmString(tsn1)")

Это означает, что в общей сложности ${tsnPaths(tsn1)} возможные пути. Сокращение для этого продукта ${tsn1} ! или ${tsn1} __Факториал__ .

Вы можете себе представить, что может быть невозможно путешествовать напрямую между двумя городами - без проезда через другой город. В этом случае у нас больше нет полного графа, и найти число гамильтоновых циклов, если они вообще существуют, становится намного сложнее.

---
> id: salesman-3

::: column.grow(parent="right")

До сих пор мы игнорировали тот факт, что некоторые города могут быть дальше друг от друга, чем другие. В реальной жизни, однако, это очень важное соображение: мы не просто хотим найти _какой-либо_ путь, мы хотим найти кратчайший путь. Это называется __проблемой коммивояжера__ . Это должно быть решено не только в сфере транспорта и логистики, но и при размещении транзисторов на микрочипах, для создания более быстрых компьютеров или при анализе структуры [ДНК](gloss:dna) .

Один простой метод - это попробовать все возможные пути, найти длину каждого, а затем выбрать самый короткий. Однако мы только что показали, что даже с ${tsn2}{tsn2|10|2,20,1} города есть ${tsn2} ! знак равно ${factorial(tsn2)} возможные пути. Если у вас есть сотни или тысячи вершин, пробовать все возможные пути становится невозможно, даже используя мощные компьютеры.

::: column(width=220)

    x-img(lightbox src="images/microchip.jpg" width=210 height=365)

:::

---
> id: salesman-4
> goals: move

К сожалению, нет более эффективного алгоритма для решения проблемы коммивояжера. Вместо этого математики и компьютерные ученые разработали различные алгоритмы, которые находят _хорошие_ решения, даже если они могут быть не самыми лучшими. Эти алгоритмы, которые дают только приблизительные решения, называются __эвристикой__ .

Попробуйте изменить расположение городов на этой карте и посмотрите, как меняется кратчайший путь между ними. Вы можете удалить города, нажав на них, и вы можете добавить города, нажав в любом месте на карте (до 8):

    figure: .tsm
      svg(width=760 height=480 viewBox="0 0 760 480")

---
> id: salesman-5

::: column.grow

__Алгоритм жадности__ (или __алгоритм__ ближайшего соседа) очень прост: вы начинаете в случайном городе и последовательно перемещаетесь в ближайший город, который вы раньше не посещали. Как только вы посетили все города, вы останавливаетесь.

::: column(width=300)

{.todo} Анимация скоро ...

:::

Вы можете показать, что в среднем пути, найденные с использованием жадного алгоритма, на 25% длиннее, чем кратчайший путь.

---
> id: salesman-6

::: column.grow

__Алгоритм 2-Opt__ начинается со случайного возможного пути. Затем вы неоднократно выбираете два ребра и меняете их местами, если это уменьшит длину пути. Вы останавливаетесь, когда не можете уменьшить длину дальше, меняя местами любые пары ребер.

::: column(width=300)

{.todo} Анимация скоро ...

:::

---
> id: ants

Оказывается, задолго до того, как компьютеры появились, Природа нашла умный способ найти оптимальные пути между разными местами: в муравьиных колониях.

    x-parallax.full-width(background="images/ants.jpg")

Муравьи хотят найти кратчайшие пути между своим гнездом и возможными источниками пищи. Они могут общаться друг с другом через химикаты, которые они оставляют на своем пути, и за которыми могут следовать другие муравьи.

---
> id: ants-1

::: column.grow

* Муравьиная колония посылает много разведчиков, которые первоначально путешествуют в случайных направлениях. Как только они находят еду, они возвращаются, оставляя след феромона. * Другие муравьи, как правило, идут по следу, когда находят его, который приводит их к еде. На обратном пути они откладывают больше феромона, тем самым усиливая след. * Со временем феромон испаряется. Чем длиннее путь, тем больше времени требуется муравьям для его прохождения, и поэтому у феромона больше времени для испарения. Короткие пути, с другой стороны, могут быть усилены быстрее, поэтому их сила увеличивается быстрее.

::: column(width=240)

{.todo} Диаграмма в ближайшее время ...

:::

---
> id: ants-2

::: column(width=220 parent="right")

    x-img(style="margin-top: 5px" src="images/ant.jpg" width=220 height=220)

::: column.grow

Алгоритмы Ant Colony System (ACS) пытаются воспроизвести это поведение на компьютерах, используя множество «виртуальных» муравьев. Они могут быстро найти очень хорошие решения для проблемы коммивояжера.

Одним из особенно полезных свойств алгоритмов ACS является то, что они могут работать непрерывно и в реальном времени адаптироваться к изменениям на графике. Эти изменения могут быть вызваны автомобильными авариями и перекрытием дорог в уличных сетях или скачками трафика на веб-серверах в компьютерных сетях.

:::

---
> id: ants-3

::: column(width=140)

    img(src="images/binary.jpg" width=140 height=320)

::: column.grow

Задача коммивояжера является [NP-трудной](gloss:np) , что означает, что ее очень трудно решить с помощью компьютеров (по крайней мере, для большого числа городов).

Поиск быстрого и точного алгоритма имел бы серьезные последствия в области компьютерных наук: это означало бы, что существуют быстрые алгоритмы для _всех_ NP-сложных задач. Это также сделает большую часть безопасности в Интернете бесполезной, поскольку полагается, что определенные проблемы считаются очень сложными для компьютеров.

Поиск быстрого алгоритма для решения проблемы коммивояжера также решил бы одну из самых известных открытых задач в математике и информатике, проблему __P vs NP__ . Это одна из семи [проблем](gloss:millennium-prize) , [связанных с премией тысячелетия](gloss:millennium-prize) , каждая из которых имеет приз в 1 миллион долларов.

:::

---
> section: scheduling
> sectionStatus: dev

## Проблемы с расписанием

{.todo} Скоро будет

---
> id: applications
> section: applications
> translated: auto

## Графики в повседневной жизни

Мы видели много разных применений теории графов в предыдущих главах, хотя некоторые из них были немного надуманными. Оказывается, однако, что графики лежат в основе многих объектов, концепций и процессов в повседневной жизни.

::: column.grow

Например, Интернет - это огромный виртуальный граф. Каждая вершина является отдельной веб-страницей, и каждое ребро означает, что между двумя страницами есть гиперссылка. Обратите внимание, что ссылки идут только в одну сторону, поэтому этот график [[направлен | многострочный | проведён,]] и что этот график _очень, очень, большой._

 Некоторые веб-сайты, такие как Википедия или Facebook, имеют много входящих ссылок, в то время как многие меньшие сайты могут иметь очень мало входящих ссылок. Это основная концепция, которую Google использует для сортировки результатов поиска.

::: column(width=240)

    img(credit="© Various" src="images/websites.png" width=240 height=240)

:::

---
> id: applications-1

Сайты с большим количеством входящих ссылок, как правило, более высокого качества и должны отображаться в верхней части результатов поиска. Например, при поиске «Лондон» официальные туристические информационные сайты показываются перед небольшими магазинами в Лондоне или блогами людей, которые живут в Лондоне. Эта простая идея из теории графов, __алгоритм Page Rank__ , сделала Google значительно лучше, чем другие ранние поисковые системы.

---
> id: applications-2

Интернет - самая большая сеть, когда-либо созданная человечеством. Это изображение показывает очень небольшую долю всех серверов, подключенных к Интернету:

    x-parallax.full-width(background="images/internet.jpg")
      .credit © LyonLabs, LLC and Barrett Lyon, 2014

---
> id: applications-3

Хотя веб-сайты и гиперссылки образуют _виртуальный_ график, существует также _физическая_ сеть компьютеров, серверов, маршрутизаторов, телефонных линий и кабелей.

::: column.grow(parent="right")

Каждый раз, когда вы звоните по телефону или загружаете веб-сайт, операторы сети должны найти способ подключения отправителя и получателя, не превышая пропускную способность любого отдельного кабеля или соединения. Теория графов и вероятность позволяют гарантировать надежное обслуживание, например, путем обнаружения отклонений, когда определенное соединение занято.

::: column(width=220)

    x-img(lightbox src="images/phone.jpg" width=220 height=166)

:::

---
> id: applications-4

Графики также играют важную роль в транспортировке и навигации. Все сети рейсов, поездов и метро образуют графики, которые можно использовать при создании эффективных расписаний. Один из самых узнаваемых графиков - карта лондонского метро:

    figure: x-img(lightbox src="images/tube-map.png" width=720 height=480 credit="© Transport for London")

---
> id: applications-5

::: column.grow

Все дороги и автомагистрали также образуют большую сеть, которая используется навигационными службами, такими как Google Maps, при разработке кратчайшего маршрута между двумя указанными точками.

::: column(width=60)

    x-img(credit="© Google" src="images/google-maps.jpg" width=70 height=70)

:::

::: column(width=280)

    x-img(lightbox src="images/congestion.jpg" width=280 height=170)

::: column.grow

В будущем __интеллектуальные транспортные системы__ сократят заторы и несчастные случаи благодаря более эффективной маршрутизации автомобилей, используя данные о местоположении, полученные со смартфонов и автомобилей с самостоятельным вождением. Это может сэкономить миллионы часов, потерянных на дороге каждый год, значительно снизить загрязнение и позволить аварийным службам быстрее путешествовать.

:::

---
> id: applications-6

На этом изображении показана сеть рейсов коммерческих авиакомпаний по всей Северной Европе.

    x-parallax.full-width(background="images/flights.jpg")

---
> id: applications-7

Есть множество других графиков в науке, технике или повседневной жизни:

::: column(width=200)

    x-img(lightbox src="images/molecules.jpg" width=200 height=200)

{.caption} Связи между атомами в __молекулах__ и кристаллических решетках образуют график.

::: column(width=200)

    x-img(lightbox src="images/epidemic.jpg" width=200 height=200)

{.caption} __Распространение болезней__ и эпидемий можно смоделировать с помощью сети.

::: column(width=200)

    x-img(lightbox src="images/evolution.jpg" width=200 height=200)

{.caption} В биологии __эволюционные деревья,__ которые показывают происхождение видов, образуют график.

::: column(width=200)

    x-img(lightbox src="images/network6.jpg" width=200 height=200)

{.caption} Различные компоненты __электрических цепей__ и компьютерных чипов образуют сеть.

::: column(width=200)

    x-img(lightbox src="images/letters.jpg" width=200 height=200)

{.caption} Грамматическая структура __языков__ может быть смоделирована с использованием графиков, например, для создания алгоритмов перевода.

::: column(width=200)

    x-img(lightbox src="images/finance.jpg" width=200 height=200)

{.caption} Графы также имеют много приложений в области __вероятности__ , __теории игр__ и __финансовой математики__ .

:::

---
> id: social

### Социальные сети

Наконец, давайте подумаем об одном особенно хорошем примере графиков, которые существуют в повседневной жизни: социальные сети. Здесь вершины представляют [[людей | друзья | сети]] и ребра представляют дружбу, лайки, подписки или подписчиков.

Когда мы рисуем графики в социальных сетях, мы можем видеть определенные __группы__ общих друзей, которые, возможно, учились в одной школе или живут в одном городе. Мы также можем определить __центральность людей__ , которая зависит от того, насколько хорошо связана вершина, и которая может быть мерой популярности человека в социальных сетях.

    figure: x-img(lightbox src="images/social-network.png" width=720 height=500)

---
> id: social-1

::: column.grow

В 2014 году у Facebook было 1,4 миллиарда активных пользователей и более 200 миллиардов друзей. Половина всех пользователей Facebook имеет более 200 друзей, а поскольку у большинства наших друзей такое же количество друзей, у нас легко могут быть десятки тысяч _друзей друзей_ .

Теперь волнующим вопросом будет: если вы выберете двух случайных пользователей Facebook, сколько «дружеских сторон» вам понадобится, чтобы перейти от одного к другому? Например, расстояние между друзьями равно [[1]] , расстояние между друзьями друзей равно [[2]] , и так далее.

::: column(width=200)

    x-img(src="images/facebook-like.png" width=200 height=200)

:::

---
> id: social-2

В 2016 году Facebook провел [исследование,](https://research.facebook.com/blog/three-and-a-half-degrees-of-separation/) чтобы определить, как его пользователи связаны друг с другом. Они обнаружили, что в среднем вы подключены к _кому-либо еще_ на Facebook через не более 3,57 других людей. И это включает в себя знаменитостей, политиков или даже роялти!

Другими словами, если вы выберете любого из миллиардов пользователей Facebook по всему миру, у них, вероятно, будет друг друга, который знает друга одного из ваших друзей. Мы говорим, что есть 3,57 __степени разделения__ .

    figure
      x-img(lightbox src="images/facebook.jpg" width=720 height=360 credit="© Facebook")
      p.caption Geographic visualisation of all Facebook friendships in 2010.

---
> id: social-3

::: column(width=200)

    x-img(credit="© Metro-Goldwyn-Mayer" src="images/six-degrees.jpg" width=200 height=265 style="border: 1px solid #ccc")

::: column.grow

В 1929 году, когда венгерский писатель [Фригес Каринти](bio:karinthy) впервые предложил идею «шести степеней разделения», не было Интернета или социальных сетей, но мир уже стал более взаимосвязанным.

В 1967 году [Стэнли Милгрэм](bio:milgram) провел первый эмпирический эксперимент, в котором 296 участников, живущих в Небраске и Канзасе, попросили доставить письмо конкретному человеку, живущему в Бостоне, штат Массачусетс. Все они должны были выбрать друга, чтобы отправить письмо, который затем выбрал другого друга. На каждом шагу письмо приближалось к Бостону. Милгрэм обнаружил, что в среднем было только 5,2 промежуточных друзей - 5,2 степени разделения.

:::

Сегодня каждый из нас является частью бесчисленных невидимых графиков, которые лежат в основе наших социальных взаимодействий, путешествий, Интернета и технологий, науки и многого другого.
